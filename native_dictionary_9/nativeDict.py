"""
TODO: Для реализации ассоциативного массива воспользуемся хэш-таблицей,
 реализованной в предыдущем занятии. По сути, требуется лишь дополнить
 ее вторым массивом self.values -- в дополнение к массиву self.slots,
 который будет хранить ключи. self.values по размеру будет таким же,
 как и self.slots, а записываются в него значения, соответствующие
 ключу слота (с таким же индексом).
 Главное отличие ассоциативного массива от хэш-таблицы в том, что он
 обычно не ограничен каким-то фиксированным размером (количеством ключей),
 и либо исходно под конкретную задачу создаётся с гарантированным запасом
 по размеру, либо сочетает возможности хэш-таблицы и динамического массива.
 Реализуйте три метода:
 - put(key, value) - сохранение внутри класса ассоциативного массива пары
   ключ-значение по описанной выше схеме;
 - is_key(key) - проверка, имеется ли в слотах такой ключ;
 - get(key) - поиск и извлечение значения по ключу, или None, если
   ключ не найден.
 Сделайте тесты, проверяющие, как работают put(), is_key() и get():
 - добавление значения по новому ключу или уже существующему ключу
   с проверками что записалось,
 - проверка присутствующего и отсутствующего ключей,
 - извлечение значения по существующему и отсутствующему ключу.
 В данном обучающем примере исходим из фиксированного размера
 ассоциативного массива. В автоматических тестах этот размер
 гарантированно не будет превышен.
"""


class NativeDictionary:
    def __init__(self, sz):
        self.size = sz
        self.slots = [None] * self.size
        self.values = [None] * self.size

    @staticmethod
    def hash(s: str, sz: int):
        return sum(s.encode()) % sz

    def hash_fun(self, key):
        # в качестве key поступают строки!
        # всегда возвращает корректный индекс слота
        return self.hash(key, self.size)

    def is_key(self, key):
        # возвращает True если ключ имеется,
        # иначе False
        return key in self.slots

    def put(self, key, value):
        # гарантированно записываем
        # значение value по ключу key
        i = self.hash_fun(key)
        self.slots[i] = key
        self.values[i] = value

    def get(self, key):
        # возвращает value для key,
        # или None если ключ не найден
        if self.is_key(key):
            i = self.hash_fun(key)
            return self.values[i]

    @classmethod
    def create(cls, sz: int, vals: dict):
        instance = cls(sz)
        for k, v in vals.items():
            instance.put(k, v)
        return instance


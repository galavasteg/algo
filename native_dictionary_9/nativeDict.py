"""
TODO: Для реализации ассоциативного массива воспользуемся хэш-таблицей,
 реализованной в предыдущем занятии. По сути, требуется лишь дополнить
 ее вторым массивом self.values -- в дополнение к массиву self.slots,
 который будет хранить ключи. self.values по размеру будет таким же,
 как и self.slots, а записываются в него значения, соответствующие
 ключу слота (с таким же индексом).
 Главное отличие ассоциативного массива от хэш-таблицы в том, что он
 обычно не ограничен каким-то фиксированным размером (количеством ключей),
 и либо исходно под конкретную задачу создаётся с гарантированным запасом
 по размеру, либо сочетает возможности хэш-таблицы и динамического массива.
 Реализуйте три метода:
 - put(key, value) - сохранение внутри класса ассоциативного массива пары
   ключ-значение по описанной выше схеме;
 - is_key(key) - проверка, имеется ли в слотах такой ключ;
 - get(key) - поиск и извлечение значения по ключу, или None, если
   ключ не найден.
 Сделайте тесты, проверяющие, как работают put(), is_key() и get():
 - добавление значения по новому ключу и добавление значения по уже
   существующему ключу с проверками что записалось, проверка
   присутствующего и отсутствующего ключей, извлечение значения по
   существующему и отсутствующему ключу.
"""


class NativeDictionary:
    def __init__(self, sz):
        self.size = sz
        self.slots = [None] * self.size
        self.values = [None] * self.size

    def hash_fun(self, key):
        # в качестве key поступают строки!
        # всегда возвращает корректный индекс слота
        return 0

    def is_key(self, key):
        # возвращает True если ключ имеется,
        # иначе False
        return False

    def put(self, key, value):
        pass
        # гарантированно записываем
        # значение value по ключу key

    def get(self, key):
        # возвращает value для key,
        # или None если ключ не найден
        return None

